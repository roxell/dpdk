#!/bin/sh
#
# dpdk-init: startup script to initialize a dpdk runtime environment
#
# Copyright 2015-2016 Canonical Ltd.
# Autor: Stefan Bader <stefan.bader@canonical.com>
# Autor: Christian Ehrhardt <christian.ehrhardt@canonical.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License version 3,
#    as published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
set -e

DPDK_BIND="/sbin/dpdk_nic_bind"
DPDK_INTERF="/etc/dpdk/interfaces"

#
# The DPDK library will use the first mounted instance it finds. So
# if there is already one, there is no need to create another.
#
hugetlbfs_mountpoint() {
    local hugetlbfsmp
    hugetlbfsmp=$(grep "hugetlbfs" /proc/mounts |sed -n '1p' \
        | sed -e 's/^ *[^ ]* //; s/ .*//g')
    echo "${hugetlbfsmp}"
}

mount_hugetlbfs() {
    if [ "$(hugetlbfs_mountpoint)" != "" ]; then
        return 0
    fi
    MNT=/dev/hugepages

    if [ ! -e $MNT ]; then
        mkdir $MNT
        if [ $? -ne 0 ]; then
            echo "Could not create directory $MNT!" >&2
            return 1
        fi
    fi
    mount -thugetlbfs hugetlbfs $MNT

    return $?
}

_setup_hugepages() {
    MMDIR="/sys/kernel/mm/hugepages/${1}"
    PAGES=${2}

    if [ "$PAGES" != "" ]; then
        if [ "$PAGES" -gt 0 ]; then
            if [ -d "$MMDIR" -a -w "$MMDIR/nr_hugepages" ]; then
                # increases the chance to allocate enough huge pages
                # configurable, since it comes at a perf penality
                if [ "$DROPCACHE_BEFORE_HP_ALLOC" = "1" ]; then
                    echo 3 > /proc/sys/vm/drop_caches
                fi

                echo "$PAGES" > "$MMDIR/nr_hugepages"

                GOTPAGES=$(cat "$MMDIR/nr_hugepages")
                if [ "$GOTPAGES" -lt "$PAGES" ]; then
                    echo "WARNING: could not allocate $PAGES at " \
                         "$MMDIR/nr_hugepages (only got $GOTPAGES)."
                fi
            else
                echo "WARNING: $MMDIR/nr_hugepages not found/writable"
            fi
        fi
    fi
}

#
# Reserve a certain amount of hugepages (defined in /etc/dpdk.conf)
#
setup_hugepages() {
    if [ ! -r /etc/dpdk/dpdk.conf ]; then
        return 1
    fi
    . /etc/dpdk/dpdk.conf

    _setup_hugepages "hugepages-2048kB" "$NR_2M_PAGES"
    _setup_hugepages "hugepages-1048576kB" "$NR_1G_PAGES"

    return 0
}

#
# Allow NICs to be automatically bound to DPDK compatible drivers on boot.
#
bind_interfaces() {
    if [ ! -r "$DPDK_INTERF" ]; then
        return 0
    fi
    grep -v '^[ \t]*#' "$DPDK_INTERF" | while read BUS ID MOD; do
        if [ "$BUS" = "" -o "$ID" = "" -o "$MOD" = "" ]; then
            echo "WARNING: incomplete spec in $DPDK_INTERF" \
                " - BUS '$BUS' ID '$ID' MOD '$MOD'"
            continue
        fi
        if [ "$BUS" != "pci" ]; then
            echo "WARNING: incompatible bus '$BUS' in $DPDK_INTERF"
            continue
        fi
        MOD=$(echo "$MOD" | tr '-' '_')

        SYSFSPATH="/sys/bus/$BUS/devices/$ID"
        if [ ! -e "$SYSFSPATH" ]; then
            echo "WARNING: invalid pci ID '$ID' in $DPDK_INTERF" \
                " - '$SYSFSPATH' does not exist"
            continue
        fi
        if [ -L "$SYSFSPATH/driver" ]; then
            CUR=$(readlink "$SYSFSPATH/driver")
            CUR=$(basename "$CUR")
            CUR=$(echo "$CUR" | tr '-' '_')
        else
            # device existing, but currently unregistered
            CUR=""
        fi
        CUR=$(readlink "/sys/bus/$BUS/devices/$ID/driver")
        CUR=$(basename "$CUR")
        CUR=$(echo "$CUR" | tr '-' '_')
        if [ "$MOD" != "$CUR" ]; then
            echo "Reassigning pci:$ID to $MOD"
            modprobe -q "$MOD" || true
            $DPDK_BIND -b "$MOD" "$ID"
        else
            echo "pci:$ID already assigned to $MOD"
        fi
    done
}



case "$1" in
start)
    mount_hugetlbfs
    setup_hugepages
    bind_interfaces
    ;;
stop)
    ;;
reload|force-reload)
    setup_hugepages
    bind_interfaces
    ;;
status)
    $DPDK_BIND --status
    ;;
*)
    echo "Usage: $0 {start|stop|reload|force-reload|status}"
    exit 1
    ;;
esac

