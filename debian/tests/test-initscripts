#!/bin/sh
set -e

basedir=$(dirname "$0")
. "${basedir}"/check-dpdk-supported-arch.sh

EXPECTHP=100
DPDK_CONF="/etc/dpdk/dpdk.conf"
DPDK_INTERF="/etc/dpdk/interfaces"

checkstatus() {
    MARK=${1}
    MPCOUNT=${2}
    PRE=${3}
    POST=${4}
    echo "Status after ${MARK}"
    echo "Status of the Service"
    ${PRE} status "${POST}" || true

    echo "Status of hugetlbfs mount points"
    # this section is ok to create bad RCs when no mounts are available
    set +e
    grep hugetlbfs < /proc/mounts
    htlbfscount=$(grep -c hugetlbfs < /proc/mounts)
    set -e

    if [ "${htlbfscount}" -eq "${MPCOUNT}" ]; then
        echo "Count (${htlbfscount}) as expected (${MPCOUNT})"
    else
        echo "Count (${htlbfscount}) not as expected (${MPCOUNT})"
        exit 1
    fi

    # check if setting HP worked
    if [ "${MPCOUNT}" -ne "0" ]; then
        MMDIR=/sys/kernel/mm/hugepages/hugepages-2048kB
        if [ -d $MMDIR -a -r $MMDIR/nr_hugepages ]; then
            hpcount=$(cat $MMDIR/nr_hugepages)
            if [ "${hpcount}" -ne "${EXPECTHP}" ]; then
                echo "Hugepages (${hpcount}) not as expected (${EXPECTHP})"
                exit 1
            else
                echo "Hugepages ok (${hpcount})"
            fi
        fi
    fi
}

resetservice() {
    # help a bit with memory fragmentation reg huge page allocation
    sync
    echo 3 > /proc/sys/vm/drop_caches

    # stopping and resetting Service
    systemctl stop dpdk.service
    systemctl reset-failed dpdk.service

    echo "Unmounting all potential hugetlbfs mounts"
    awk '/hugetlbfs/ {print $2}' /proc/mounts | while read hugetlbmount; do
        umount -v "$hugetlbmount"
    done
}

checkinitstyle() {
    # We want to verify that
    # - initially out environment has no hugetlbfs mount
    # - a system without hugetlbfs mount gets it mounted
    # - a restart of the service does neither drop nor duplicate the mount
    PRE=${1}
    POST=${2}
    TYPE=${3}
    printf "\n\n### Checking Type %s ###\n" "${TYPE}"
    resetservice
    checkstatus "${TYPE}-BEGIN" 0 "${PRE}" "${POST}"
    echo "### Starting Service ###"
    ${PRE} start "${POST}"
    checkstatus "${TYPE}-START" 1 "${PRE}" "${POST}"
    echo "### Restarting Service ###"
    ${PRE} restart "${POST}"
    checkstatus "${TYPE}-RESTART" 1 "${PRE}" "${POST}"
}

# a low amount of HP, works in isolation-machine and we can check if it appears
echo "NR_2M_PAGES=$EXPECTHP" >> ${DPDK_CONF}

# While we can't rely on any real device for DPDK tests in adt-* environments
# we can expect all kind of broken config not to break it (would be detected
# via set -e). Add all kind of broken definitions and expect it not to fail.
cat <<EOF > ${DPDK_INTERF}
# wrong bus
pTi 0000:04:00.0 uio-pci-generic
# not enough parms
0000:04:00.0 uio-pci-generic
# empty line

# non existing device
pci 1234:56:78.9 uio-pci-generic
# bad module name
0000:01:00.0 foo-bar-module
EOF

# some had issues in the past caused by different environments, so we test all
# Direct Calls
checkinitstyle "/etc/init.d/dpdk" "" "Direct"
# System V style init
checkinitstyle "service dpdk" "" "SysV"
# SystemD style init
checkinitstyle "systemctl" "dpdk.service" "SystemD"
